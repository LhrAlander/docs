> 该文章翻译自[CSS GPU Animation: Doing It Right](https://www.smashingmagazine.com/2016/12/gpu-animation-doing-it-right/#top)

# 正确使用 CSS GPU 动画

> 速览 -> 本文旨在通过帮助读者理解浏览器是如何使用 GPU 进行渲染画面以构建出在任何设备上都能流畅运行的优秀的网站。

**目前，大多数人都知道现代化的浏览器会对web页面的某些部分（尤其是带有动画的部分）采取GPU渲染。** 例如，使用 ``transform`` 属性的动画看起来就比使用``left``或者``top``这些属性的动画平滑得多。如果你询问“我如何才能使用GPU来渲染一个流畅平滑的动画呢？”，大多数情况下，你得到的回答应该是使用``transform: translateZ(0)`` 或者 ``will-change: transform``.

有时候我们的动画在一个简单的demo中运行的流畅平滑，但是到了真正的网站中，这些动画甚至会是的浏览器崩溃。我们一起来理解背后的原因和解决办法。

## 艰巨的开始

阅读本文前有一个很重要的前置认知：你没办法从W3C的规范中找到任何关于合成（compositing）是如何运作的、如何步骤清晰地将一个元素放到复合层（compositing layer）上，甚至没有任何规范描述何为 **合成**。因此这可能对读者来说是个巨大的黑洞。合成只是浏览器在处理一些特定任务时做的一些优化操作，并且不同的浏览器都对合成有不同的实现方式。

在你继续阅读前我不得不先提醒你：你在本文中了解到的并不是对合成的官方说明解释，而是我利用自己对不同浏览器子系统的工作原理知识做的一些实验的实验结果。在这过程中，可能实验结果出现了错误抑或是这些结果会随着时间的推移而发生变化。

## 如何进行合成(Compositing)

让我们准备一个页面来了解GPU动画，我们需要深入了解页面的绘制是如何在浏览器中完成的，而不是从网上随便找一些文章去看他们的解释。

假设我们的页面上存在 ``A`` 和 ``B`` 两个元素，它们都具备CSS属性 ``position: absolute``，同时为它们设置不同的 ``z-index`` 值。浏览器会将CPU绘制的图像发送给GPU，GPU将图像绘制在屏幕上。

```html
<style>
#a,
#b {
  position: absolute;
}

#a {
  left: 30px;
  top: 30px;
  z-idex: 2;
}

#b {
  z-index: 1;
}
</style>

<div id="a"></div>
<div id="b"></div>
````

接着我们希望通过使用 ``left`` 和 CSS动画让A产生移动动画。

```html
<style>
#a,
#b {
 position: absolute;
}

#a {
 left: 10px;
 top: 10px;
 z-index: 2;
 animation: move 1s linear;
}

#b {
 left: 50px;
 top: 50px;
 z-index: 1;
}

@keyframes move {
 from { left: 30px; }
 to { left: 100px; }
}
</style>
<div id="#a">A</div>
<div id="#b">B</div>

````

在上面这个例子中，浏览器必须在动画的每一帧都计算出元素的几何属性（即回流），将页面重新绘制（即重绘）后传给GPU以显示在显示屏上。我们应该知道重绘是一件十分耗性能的事，但是大部分的现代浏览器在处理重绘上都已经足够智能地只重绘页面的一部分而非整个页面。尽管浏览器在大多数情况下可以非常快速地重绘，我们的动画仍然不流畅。

在动画的每一帧都将整个页面进行回流和重绘（即使是增量式的）听起来是一个十分缓慢的过程，在复杂的大型页面中尤甚。但是有一个高效的方法是让浏览器只绘制两个独立的图像————一个是元素 ``A`` 的图像，一个是不包含元素 ``A`` 的整个页面的图像；然后让两幅图像进行相对偏移（译者注：应该是让其中的一幅图像进行偏移？）。换言之，使用缓存元素来绘制图像会快上很多。而这正是GPU的优势所在：GPU能够以亚像素精度快速地绘制图像，从而使动画更加平滑。

（浏览器）为了优化合成工作，浏览器必须保证那些具备动画的CSS属性有以下几个特点：
   - 不影响文档流
   - 不依赖文档流
   - 不会引起重绘

你也许会认为 ``top``、``left``以及伴随它们的 ``position: absolute / fixed`` 是不依赖与文档流的。事实并非如此，举个例子，一个元素应用 ``left`` 属性时可能会接收一个根据父元素的几何属性的百分比值作为值；同样可以作为 ``left`` 属性值的一些单位如 ``em``、``vh`` 等都依赖于文档流。于是，能够满足上述三个特点的CSS属性其实只有 ``transform`` 和 ``opacity``。

现在，让我们使用 ``transform`` 属性代替 ``left`` 属性来完成动画：
```html
<style>
#a,
#b {
 position: absolute;
}

#a {
 left: 10px;
 top: 10px;
 z-index: 2;
 animation: move 1s linear;
}

#b {
 left: 50px;
 top: 50px;
 z-index: 1;
}

@keyframes move {
 from { transform: translateX(0); }
 to { transform: translateX(70px); }
}
</style>
<div id="#a">A</div>
<div id="#b">B</div>

````

在上述这个动画中，由于我们阶段式地声明了动画的过程：如开始时和结束时的位置，浏览器可以提前解析出哪些CSS属性将被更新。与此同时，浏览器发现这些要被更新的CSS属性不会造成回流和重绘后，对合成工作采取了优化措施：将两个图像绘制成一个合成层交给GPU。

这样优化后有什么优点呢？
  - 我们可以构建亚像素精度的流畅动画，该动画会运行在专门为图形化任务优化过的单元上，而且运行极快。
  - 动画将不再运行在CPU上。这意味着即使你运行极其繁琐的JavaScript任务也不会影响到动画，它依旧会流畅运行。

目前为止，一切都看起来简单明了。但是在使用的过程中我们会遇到什么问题呢？让我们看看优化是如何运行的。

首先要说一个让读者们惊奇的说法：GPU是一台独立运行的计算机：其作为任何一个现代设备都必不可少的一部分的同时，还是一个拥有独立的处理器、内存和数据处理模型的独立单元。因此，浏览器和其他程序或者游戏一样必需向GPU进行通信，这就像浏览器必需和外部设备通信一样。

有一个很好的例子来形容通信过程：AJAX。想象一下当用户进入你的网站并填写了注册表单后，你需要使用用户填写的表单信息来为其注册成为你的网站用户。你不能只是简单地告诉服务端：“嘿，快来把我页面中的input元素里面的数据拿走并将它们存入到数据库中去。”服务端并不具备访问用户浏览器内存的权限。因此，浏览器需要自己收集信息，然后用一种特定格式封装这些数据（如JSON），最后将数据发送给服务端让其完成相应操作。

合成 这个流程其实很像AJAX的沟通流程。因为GPU就是在扮演服务端的角色，浏览器要做的是必须先构造出数据然后将数据传送给GPU。当然，GPU离CPU十分地近没有服务器离用户有几百上千公里那么远，但是你要知道，在很多情况下，远程服务器响应的时间需要2s是可以接受的，而GPU数据传输哪怕多上2~2毫秒都将导致动画的不稳定。
